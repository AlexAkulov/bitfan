package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/clbanning/mxj"
	"github.com/k0kubun/pp"
	"github.com/vjeantet/bitfan/processors/doc"
)

var (
	processorStructName = flag.String("processor", "processor", "name of BitFan Processor")
	output              = flag.String("output", "docdoc.go", "output file name; default docdoc.go")
)

func main() {

	flag.Parse()

	// récupérer le path
	cwd, _ := os.Getwd()

	// charger un doc.Processor
	dp, _ := doc.NewProcessor(cwd)

	JsonFilePath := filepath.Join(cwd+"../../../docs/data/processors/", strings.ToLower(dp.Name)+".json")
	dataMap, _ := mxj.NewMapStruct(dp)
	jsonBytes, _ := dataMap.JsonIndent("", "  ", true)
	if err := ioutil.WriteFile(filepath.Clean(JsonFilePath), jsonBytes, 0644); err != nil {
		log.Printf("writing output: %s\n", err)
	}

	g := &Generator{
		buf: bytes.Buffer{},
	}

	// Génère le contenu
	// Print the header and package clause.
	g.Printf("// Code generated by \"bitfanDoc %s\"; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("package %s\n\n", dp.Name)
	g.Printf("import \"github.com/vjeantet/bitfan/processors/doc\"\n\n") // Used by all methods.
	g.Printf("func (p *%s) Doc() *doc.Processor {\n\treturn ", *processorStructName)

	w := bufio.NewWriter(&g.buf)
	pp.ColoringEnabled = false
	pp.Fprint(w, dp)
	w.Flush()
	g.Printf("\n}")

	// Ecrit le contenu
	// fmt.Println(string(g.buf.Bytes()))

	outputName := *output
	outputName = filepath.Join(cwd, strings.ToLower(*output))
	err := ioutil.WriteFile(outputName, g.buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}

	outputName = filepath.Join(cwd, strings.ToLower("README.md"))
	err = ioutil.WriteFile(outputName, dp.GenMarkdown("logstash"), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}
	// Exit
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}
