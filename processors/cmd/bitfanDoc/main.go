package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/clbanning/mxj"
	"github.com/k0kubun/pp"
	"github.com/vjeantet/bitfan/processors/doc"
)

var (
	codecStructName     = flag.String("codec", "", "name of BitFan Codec")
	processorStructName = flag.String("processor", "processor", "name of BitFan Processor")
	output              = flag.String("output", "docdoc.go", "output file name; default docdoc.go")
)

func main() {

	flag.Parse()

	// récupérer le path
	cwd, _ := os.Getwd()

	var dp = &doc.Documentation{}

	var dataJsonDocsPath string = ""

	if *codecStructName != "" {
		// charger un doc.Codec
		dataJsonDocsPath = cwd + "../../../docs/data/codecs/"
		ddc, _ := doc.NewCodec(cwd)
		dp.Codec = ddc
	} else {
		// charger un doc.Processor
		dataJsonDocsPath = cwd + "../../../docs/data/processors/"
		ddp, _ := doc.NewProcessor(cwd)
		dp.Processor = ddp
	}

	JsonFilePath := filepath.Join(dataJsonDocsPath, strings.ToLower(dp.Name())+".json")
	dataMap, _ := mxj.NewMapStruct(dp.Struct())
	jsonBytes, _ := dataMap.JsonIndent("", "  ", true)
	if err := ioutil.WriteFile(filepath.Clean(JsonFilePath), jsonBytes, 0644); err != nil {
		log.Printf("writing output: %s\n", err)
	}

	g := &Generator{
		buf: bytes.Buffer{},
	}

	// Génère le contenu
	// Print the header and package clause.
	g.Printf("// Code generated by \"bitfanDoc %s\"; DO NOT EDIT\n", strings.Join(os.Args[1:], " "))
	g.Printf("package %s\n\n", dp.Name())
	g.Printf("import \"github.com/vjeantet/bitfan/processors/doc\"\n\n") // Used by all methods.
	if *codecStructName != "" {
		g.Printf("func (p *%s) Doc() *doc.Codec {\n\treturn ", *codecStructName)
	} else {
		g.Printf("func (p *%s) Doc() *doc.Processor {\n\treturn ", *processorStructName)
	}

	w := bufio.NewWriter(&g.buf)
	pp.ColoringEnabled = false
	pp.Fprint(w, dp.Struct())
	w.Flush()
	g.Printf("\n}")

	// Ecrit le contenu
	// fmt.Println(string(g.buf.Bytes()))

	outputName := *output
	outputName = filepath.Join(cwd, strings.ToLower(*output))
	err := ioutil.WriteFile(outputName, g.buf.Bytes(), 0644)
	if err != nil {
		log.Fatalf("writing output: %s", err)
	}

	if *codecStructName != "" {
	} else {
		outputName = filepath.Join(cwd, strings.ToLower("README.md"))
		err = ioutil.WriteFile(outputName, dp.Processor.GenMarkdown("logstash"), 0644)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
	// Exit
}

// Generator holds the state of the analysis. Primarily used to buffer
// the output for format.Source.
type Generator struct {
	buf bytes.Buffer // Accumulated output.
}

func (g *Generator) Printf(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}
